#' MetDIA: MetDIA: Targeted Metabolite Extraction of Multiplexed MS/MS Spectra Generated by Data-Independent Acquisition
#' MetDIA: MetDIA: Targeted Metabolite Extraction of Multiplexed MS/MS Spectra Generated by Data-Independent Acquisition 
#' @param filepath file path of data. different group data should be put into different folder
#' @param spcelib library information contains precursor ion m/z, fragment ion of m/z and relative intensity, name
#' @param ppm.pd tolerance for peak detection
#' @param sn singal to noise ratio for peak detection
#' @param peakwidth peak width for peak detection
#' @param ms1ppm tolerance for MS1 match
#' @param ms2ppm tolerance for MS2 match
#' @param cutoff minium MCI score cutoff
#' @param inf.detail detail inforamtion for refine result, containing metabolite name, lab ID, KEGG ID, HMDB ID and so on
#' @param refine whether refine the result or not
#' @param ms2.quant whether output ms2 quant result

MetDIA <- function(filepath, speclib, ppm.pd = 25, sn = 6, peakwidth = c(5, 30), ms1ppm = 25, ms2ppm = 35, cutoff = 0.8, inf.detail = metinf.detail, refine = TRUE, ms2.quant = FALSE){
  require(xcms)
  setwd(filepath)
  file <- list.files(filepath, recursive = TRUE, full.names = TRUE, pattern = "mzXML")
  file.windows <- read.csv("windows.csv", stringsAsFactor = FALSE)
  xraw.list <- sapply(file, function(y) xcmsRaw(y, includeMSn = TRUE))
  
  # extract MS1 scantime, mass range, scan
  scantime.ms1.raw <- lapply(xraw.list, function(xraw.single)  xraw.single @ scantime)
  massrange.ms1 <- lapply(xraw.list, function(xraw.single) xraw.single @ mzrange)
  scan.ms1.raw <- lapply(1:length(scantime.ms1.raw), function(sample.num){
    lapply(1:length(scantime.ms1.raw[[sample.num]]), function(y){
      getScan(xraw.list[[sample.num]], y)
    })
  })
  
  # extract MS2 scantime, scan. May have missing MS2 scans
  xrawn.list <- sapply(xraw.list, msn2xcmsRaw)
  scantime.ms2 <- lapply(xrawn.list, function(xrawn.single) xrawn.single @ scantime)
  scan.ms2.raw <- lapply(1:length(scantime.ms2), function(sample.num){
    lapply(1:length(scantime.ms2[[sample.num]]), function(y){
      getScan(xrawn.list[[sample.num]], y)
    })
  })
  
  # ms1.scanmissing
  num.ms1scan <- sapply(scantime.ms1.raw, length)
  if(any(num.ms1scan != max(num.ms1scan))){
    print("There may be missing MS1 scans!")
    scantime.ms1 <- CompleteMs1Scantime(scantime.ms1.raw)
    scan.ms1 <- CompleteMs1Scan(scantime.ms1.raw, scan.ms1.raw)
  }else{
    scantime.ms1 <- scantime.ms1.raw
    scan.ms1 <- scan.ms1.raw
  }
  
  # check whether there are missing MS2 scans.
  check.scanmissing <- sapply(seq(scan.ms2.raw), function(y){
    length(scan.ms2.raw[[y]]) / length(scantime.ms1[[y]]) != round(length(scan.ms2.raw[[y]]) / length(scantime.ms1[[y]]))
  })
  if(any(check.scanmissing)){
    print("There may be missing MS2 scans!")
    scan.ms2 <- lapply(seq(scan.ms2.raw), function(y){
      CompleteMs2Scan(scantime.ms1[[y]], scantime.ms2[[y]], scan.ms2.raw[[y]])
    })
    
    tmp <- sapply(seq(scan.ms2), function(y){
      length(scan.ms2[[y]]) / length(scantime.ms1[[y]]) != round(length(scan.ms2[[y]]) / length(scantime.ms1[[y]]))
    })
    if(any(tmp))
      print("error, MS2 scans cannot be completed!!!")
    else
      print("MS2 scans have been completed.")
  }else{
    scan.ms2 <- scan.ms2.raw
  }
  
  
  # xcms preprocessing: peak detection
  xset <- xcmsSet(file, method = "centWave", ppm = ppm.pd, snthr = sn, peakwidth = peakwidth, mzdiff = 0.01, nSlaves = 12)
  sampnum <- seq(length(sampnames(xset)))
  
  if(length(sampnum) == 1){
    # skip alignment for single file
    peaktable <- xset @ peaks
    peakgroup.raw <- lapply(1:nrow(peaktable), function(rowidx) peaktable[rowidx, , drop = FALSE])
    peakgroup.corrected <- peakgroup.raw
    save(file.path, ms1ppm, ms2ppm, speclib, xraw.list, xset, file = "xcms part.Rdata")
  }else{
    # process alignment
    xset <- group(xset)  # match peaks across samples, first time
    xset2 <- retcor(xset, method = "obiwarp", plottype = "deviation", profStep = 0.1)  # RT correction (choose the one which has most peak number as reference)
    xset2 <- group(xset2, bw = 10)  # match peaks across samples, first time
    xset3 <- fillPeaks(xset2)  # fill in missing peak data
    
    # peakgroup index: 1 sample 1 index
    sampnum <- seq(length(sampnames(xset)))
    groupindex <- xset3 @ groupidx
    peaktable <- xset3 @ peaks
    groupindex.single <- lapply(1:length(groupindex), function(y) {  # each sample only contribute one peak to a peakgroup, deal with peaks more than sample number in one group, keep RT closest one
      idx <- groupindex[[y]][order(abs(peaktable[groupindex[[y]], "rt"] - median(peaktable[groupindex[[y]], "rt"])))]
      idx[match(sampnum, peaktable[idx, "sample"])]
    })
    
    peakgroup.raw <- PeakGroupRaw(xset3, groupindex.single)
    peakgroup.corrected <- lapply(groupindex.single, function(y) xset3 @ peaks[y, , drop = FALSE])
    save(file.path, ms1ppm, ms2ppm, speclib, xraw.list, xset, xset2, xset3, file = "xcms part.Rdata")
  }
  
  # group oriented
  # extract peak information, calculate dot product and correlation, plot
  dpr <- lapply(1:length(peakgroup.raw), function(peakgroup.num){
    lapply(1:length(speclib), function(speclib.num){
      PKtoDP(peaktable = peakgroup.raw[[peakgroup.num]],
             peaktable.corrected = peakgroup.corrected[[peakgroup.num]],
             scantime = scantime.ms1,
             speclib.single = speclib[[speclib.num]],
             scan.ms1 = scan.ms1,
             scan.ms2 = scan.ms2,
             ms1ppm = ms1ppm,
             ms2ppm = ms2ppm,
             peakgroup.num = peakgroup.num,  # for plot
             massrange.ms1 = massrange.ms1,
             mcicutoff = cutoff,
             windows = file.windows)
    })
  })
  save(dpr, file = "dpr.Rdata")

  # name each matched peak
  dpr.name <- lapply(dpr, function(y) {
    names(y) <- names(speclib)
    y
  })
  # ȥremove NA in result
  dpr.naremove <- lapply(dpr.name, function(dpr.list){
    idx.notna <- sapply(dpr.list, function(dpr.single){
      ! all(is.na(dpr.single))
    })
    dpr.list[idx.notna]
  })
  save(dpr.naremove, file = "dpr.naremove.Rdata")
  
  # both dot product and correlation are more than 0.8 will be consider as identified
  dpr.hit.eachsample <- lapply(dpr.naremove, function(dpr.naremove.single) {
    if(length(dpr.naremove.single) == 0) return(NA)
    dpr.nar.s.name <- lapply(1:length(dpr.naremove.single), function(y){
      name <- names(dpr.naremove.single[y])
      cbind(name, dpr.naremove.single[[y]])
    })
    dpr.nar.s.n.combine <- do.call(rbind, dpr.nar.s.name)
    sampleidx <- unique(dpr.nar.s.n.combine[, "sample"])
    sampleidx.o <- sampleidx[order(sampleidx)]
    hit.allsample.list <- lapply(sampleidx.o, function(y){
      hit.1sample <- dpr.nar.s.n.combine[dpr.nar.s.n.combine[, "sample"] == y, , drop = FALSE]
      idx <- as.numeric(hit.1sample[, "dpc"]) >= cutoff & as.numeric(hit.1sample[, "cormean.part"]) >= cutoff
      if(any(idx)){
        hit.1sample[idx, , drop = FALSE]
      }else{
        hit.1sample[which.max(hit.1sample[, "score.cpart"]), , drop = FALSE]
      }
    })
    do.call(rbind, hit.allsample.list)
  })
  
  if(ms2.quant == TRUE){
    area <- lapply(1:length(peakgroup.raw), function(peakgroup.num){
      lapply(1:length(speclib), function(speclib.num){
        Area(peaktable = peakgroup.raw[[peakgroup.num]],
             peaktable.corrected = peakgroup.corrected[[peakgroup.num]],
             scantime = scantime.ms1,
             speclib.single = speclib[[speclib.num]],
             scan.ms1 = scan.ms1,
             scan.ms2 = scan.ms2,
             ms1ppm = ms1ppm,
             ms2ppm = ms2ppm,
             peakgroup.num = peakgroup.num,  # for plot
             massrange.ms1 = massrange.ms1,
             mcicutoff = cutoff,
             windows = file.windows)
      })
    })
    
    # name each matched peak
    area.name <- lapply(area, function(y) {
      names(y) <- names(speclib)
      y
    })
    
    # ȥremove NA in result
    area.naremove <- lapply(area.name, function(area.list){
      idx.notna <- sapply(area.list, function(area.single){
        ! all(is.na(area.single))
      })
      area.list[idx.notna]
    })
    
    area.hit.eachsample <- lapply(area.naremove, function(area.naremove.s){
      if(length(area.naremove.s) == 0) return(NA)
      area.nar.s.name <- lapply(1:length(area.naremove.s), function(y){
        name <- names(area.naremove.s[y])
        cbind(name, area.naremove.s[[y]])
      })
      area.nar.s.n.combine <- do.call(rbind, area.nar.s.name)
      sampleidx <- unique(area.nar.s.n.combine[, "sample"])
      sampleidx.o <- sampleidx[order(sampleidx)]
      hit.allsample.list <- lapply(sampleidx.o, function(y){
        hit.1sample <- area.nar.s.n.combine[area.nar.s.n.combine[, "sample"] == y, , drop = FALSE]
      })
      do.call(rbind, hit.allsample.list)
    })
    
    # which(sapply(dpr.hit.eachsample, function(y) ifelse(all(is.na(y)), 0, nrow(y))) > 3)
    # swath result in each sample, "name, dot product, correlation"
    area.result <- lapply(area.hit.eachsample, function(area.h.e.s){
      score <- matrix(NA, ncol = length(sampnames(xset)))
      colnames(score) <- sampnames(xset)
      if(is.na(area.h.e.s)) return(score)
      partinformation <- area.h.e.s[, c("name", "area", "sample"), drop = FALSE]
      for(i in 1:nrow(partinformation)){
        if(all(is.na(score[1, as.numeric(partinformation[i, "sample"])]))){
          score[1, as.numeric(partinformation[i, "sample"])] <-
            paste(partinformation[i, "name"],
                  partinformation[i, "area"],
                  sep = " ")
        }else{
          score[1, as.numeric(partinformation[i, "sample"])] <-
            paste(score[1, as.numeric(partinformation[i, "sample"])],
                  paste(partinformation[i, "name"],
                        partinformation[i, "area"],
                        sep = " "),
                  sep = "|")
        }
      }
      score
    })
  }
  
  swath.result <- lapply(dpr.hit.eachsample, function(dpr.al1mt.single){
    score <- matrix(NA, ncol = length(sampnames(xset)))
    colnames(score) <- sampnames(xset)
    if(is.na(dpr.al1mt.single)) return(score)
    partinformation <- dpr.al1mt.single[, c("name", "dpc", "cormean.part", "sample"), drop = FALSE]
    for(i in 1:nrow(partinformation)){
      if(all(is.na(score[1, as.numeric(partinformation[i, "sample"])]))){
        score[1, as.numeric(partinformation[i, "sample"])] <-
          paste(partinformation[i, "name"],
                partinformation[i, "dpc"],
                partinformation[i, "cormean.part"],
                sep = ",")
      }else{
        score[1, as.numeric(partinformation[i, "sample"])] <-
          paste(score[1, as.numeric(partinformation[i, "sample"])],
                paste(partinformation[i, "name"],
                      partinformation[i, "dpc"],
                      partinformation[i, "cormean.part"],
                      sep = ","),
                sep = ";")
      }
    }
    score
  })
  
  # name and score in all sample, name and socre in matched sample
  matchscore.result <- lapply(dpr.hit.eachsample, function(dpr.al1mt.single){
    score <- matrix(NA, ncol = 4)
    colnames(score) <- c("name.mean all", "score.mean all", "name.mean matched", "score.mean matched")
    if(is.na(dpr.al1mt.single)) return(score)
    if(! any(dpr.al1mt.single[, "dpc"] >= cutoff & dpr.al1mt.single[, "cormean.part"] >= cutoff)) return(score)
    
    partinformation <- dpr.al1mt.single[, c("name", "score.cpart", "dpc", "cormean.part", "sample"), drop = FALSE]
    name <- unique(partinformation[, "name"])
    group.name <- lapply(name, function(y){
      partinformation[partinformation[, "name"] == y, , drop = FALSE]
    })
    mean.all <- sapply(group.name, function(y) round(sum(as.numeric(y[, "score.cpart"])) / length(sampnames(xset)), 3))
    score[1, 2] <- mean.all[which.max(mean.all)]
    namescore.all <- group.name[[which.max(mean.all)]][1, "name"]
    score[1, 1] <- namescore.all
    
    mean.matched <- sapply(group.name, function(y) round(mean(as.numeric(y[, "score.cpart"])), 3))
    score[1, 4] <- mean.matched[which.max(mean.matched)]
    namescore.matched <- group.name[[which.max(mean.matched)]][1, 1]
    score[1, 3] <- namescore.matched
    
    score
  })
  
  # calculate the first hit
  firsthit.result <- lapply(dpr.naremove, function(dpr.naremove.single) {
    fh.result <- matrix(NA, ncol = 2)
    colnames(fh.result) <- c("first hit name", "first hit time")
    if(length(dpr.naremove.single) == 0) return(fh.result)
    
    dpr.nar.s.name <- lapply(1:length(dpr.naremove.single), function(y){
      name <- names(dpr.naremove.single[y])
      cbind(name, dpr.naremove.single[[y]])
    })
    dpr.nar.s.n.combine <- do.call(rbind, dpr.nar.s.name)
    sampleidx <- unique(dpr.nar.s.n.combine[, "sample"])
    sampleidx.o <- sampleidx[order(sampleidx)]
    hit.allsample.list <- lapply(sampleidx.o, function(y){
      hit.1sample <- dpr.nar.s.n.combine[dpr.nar.s.n.combine[, "sample"] == y, , drop = FALSE]
      hit.1sample.o <- hit.1sample[order(hit.1sample[, "score.cpart"], decreasing = TRUE), , drop = FALSE]
      hit.1sample.o[1, , drop = FALSE]
    })
    firsthit <- do.call(rbind, hit.allsample.list)
    if(! any(firsthit[, "dpc"] >= cutoff & firsthit[, "cormean.part"] >= cutoff)) return(fh.result)
    idx <- which.max(table(firsthit[, "name"]))
    fh.result[1, 1] <- names(table(firsthit[, "name"])[idx])
    fh.result[1, 2] <- table(firsthit[, "name"])[idx]
    return(fh.result)
  })
  
  highestscore.result <- lapply(dpr.hit.eachsample, function(dpr.al1mt.single){
    score <- data.frame(id.add = NA, MCI = NA, SSM = NA, PPC = NA)
    # colnames(score) <- c("name.mean all", "score.mean all", "name.mean matched", "score.mean matched")
    if(is.na(dpr.al1mt.single)) return(score)
    if(! any(dpr.al1mt.single[, "dpc"] >= cutoff & dpr.al1mt.single[, "cormean.part"] >= cutoff)) return(score)
    
    partinformation <- dpr.al1mt.single[, c("name", "score.cpart", "dpc", "cormean.part", "sample"), drop = FALSE]
    name <- unique(partinformation[, "name"])
    group.name <- lapply(name, function(y){
      partinformation[partinformation[, "name"] == y, , drop = FALSE]
    })
    
    score.max.list <- lapply(group.name, function(group.single){
      idx.order <- order(as.numeric(group.single[, "score.cpart"]), decreasing = TRUE)
      group.order <- group.single[idx.order, , drop = FALSE]
      idx <- as.numeric(group.order[, "dpc"]) >= cutoff &
        as.numeric(group.order[, "cormean.part"]) >= cutoff
      
      if(sum(idx) == 0){
        matrix(NA, ncol = ncol(group.single))
      }else{
        group.order[idx, , drop = FALSE][1, , drop = FALSE]
      }
    })
    
    score.max <- do.call(rbind, score.max.list)
    score[1, 1] <- score.max[which.max(as.numeric(score.max[, 2]))[1], "name"]
    score[1, 2] <- score.max[which.max(as.numeric(score.max[, 2]))[1], "score.cpart"]
    score[1, "PPC"] <- score.max[which.max(as.numeric(score.max[, 2]))[1], "cormean.part"]
    score[1, "SSM"] <- score.max[which.max(as.numeric(score.max[, 2]))[1], "dpc"]
    
    score
  })
  
  if(length(sampnum) == 1){
    report.raw <- cbind(do.call(rbind, peakgroup.raw),
                        do.call(rbind, swath.result),
                        do.call(rbind, firsthit.result),
                        do.call(rbind, matchscore.result),
                        do.call(rbind, highestscore.result))
    
    # calculate ms2 quant information for single file
    if(ms2.quant){
      report.quant.raw <- cbind(do.call(rbind, peakgroup.raw),
                                do.call(rbind, swath.result),
                                do.call(rbind, area.result))
    }

    report.all <- report.raw
  }else{
    ms1.report <- diffreport(xset3, value = "into", sortpval = FALSE)
    report.raw <- cbind(ms1.report,
                        do.call(rbind, highestscore.result),
                        do.call(rbind, swath.result),
                        do.call(rbind, firsthit.result),
                        do.call(rbind, matchscore.result))
    
    # calculate ms2 quant information for single file
    if(ms2.quant){
      report.quant.raw <- cbind(ms1.report[, c("name", "mzmed", "mzmin", "mzmax", "rtmed", "rtmin", "rtmax")],  # !!!
                                do.call(rbind, highestscore.result),
                                do.call(rbind, swath.result),
                                do.call(rbind, area.result))
    }
    
    if(refine == TRUE){
      report.all <- RefineReuslt(report.raw, metinf.detail, sampnames(xset))
    }else{
      report.all <- report.raw
    }
  }

  if(ms2.quant){
    report.quant <- RefineReuslt.ms2(report.quant.raw, metinf.detail, sampnames(xset))
    write.csv(report.quant, "report quantitation with MS2.csv")
  }
  
  write.csv(report.all, "report.csv")
}